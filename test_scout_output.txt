============================= test session starts =============================
platform win32 -- Python 3.13.1, pytest-8.4.2, pluggy-1.6.0
rootdir: C:\Users\acord\OneDrive\Desktop\Biblioteca MCP\Ultragent
configfile: pyproject.toml
plugins: anyio-4.9.0, libtmux-0.53.0, asyncio-1.3.0, html-4.2.0, metadata-3.1.1
asyncio: mode=Mode.AUTO, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 11 items

tests\test_scout.py F...F.E.F.F                                          [100%]

=================================== ERRORS ====================================
_________________ ERROR at setup of test_async_search_result __________________

    @fixture
    async def async_search_result():
>       return SearchResult(
            title="Test Title",
            url="https://test.url.com",
        )
E       TypeError: SearchResult.__init__() missing 3 required positional arguments: 'snippet', 'source_type', and 'date'

tests\test_scout.py:129: TypeError
================================== FAILURES ===================================
________________________ test_stack_profile_from_file _________________________

    def test_stack_profile_from_file():
        with patch("scout.json.loads") as mock_json_loads:
            mock_json_loads.return_value = {
                "project_name": "Test Project",
                "core_frameworks": ["framework1", "framework2"],
                "libraries": ["lib1", "lib2"],
                "constraints": {"constraint1": "value1", "constraint2": "value2"},
            }
            profile = StackProfile.from_file(Path("test.json"))
>           assert profile.project_name == "Test Project"
E           AssertionError: assert 'Default' == 'Test Project'
E             
E             - Test Project
E             + Default

tests\test_scout.py:80: AssertionError
_____________________________ test_search_result ______________________________

    def test_search_result():
>       result = SearchResult(
            title="Test Title",
            url="https://test.url.com",
        )
E       TypeError: SearchResult.__init__() missing 3 required positional arguments: 'snippet', 'source_type', and 'date'

tests\test_scout.py:110: TypeError
____________________ test_repository_health_invalid_input _____________________

self = <unittest.mock._patch object at 0x00000136AA295BA0>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           TypeError: cannot set 'now' attribute of immutable type 'datetime.datetime'

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1609: TypeError

During handling of the above exception, another exception occurred:

repository_health = RepositoryHealth(name='Test Repository', full_name='Test Owner/Test Repository', url='https://github.com/Test Owner/Te...tetime.datetime(2026, 2, 6, 5, 12, 5, 213962), has_tests=True, has_typing=True, has_readme=True, commit_frequency=10.0)

    def test_repository_health_invalid_input(repository_health):
>       with patch("scout.datetime.now") as mock_now:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_scout.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x00000136AA295BA0>
exc_info = (<class 'TypeError'>, TypeError("cannot set 'now' attribute of immutable type 'datetime.datetime'"), <traceback object at 0x00000136AA31F400>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
>           setattr(self.target, self.attribute, self.temp_original)
E           TypeError: cannot set 'now' attribute of immutable type 'datetime.datetime'

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1631: TypeError
______________________ test_search_result_invalid_input _______________________

    def test_search_result_invalid_input():
>       result = SearchResult(
            title=None,
            url=None,
        )
E       TypeError: SearchResult.__init__() missing 3 required positional arguments: 'snippet', 'source_type', and 'date'

tests\test_scout.py:178: TypeError
=========================== short test summary info ===========================
FAILED tests/test_scout.py::test_stack_profile_from_file - AssertionError: as...
FAILED tests/test_scout.py::test_search_result - TypeError: SearchResult.__in...
FAILED tests/test_scout.py::test_repository_health_invalid_input - TypeError:...
FAILED tests/test_scout.py::test_search_result_invalid_input - TypeError: Sea...
ERROR tests/test_scout.py::test_async_search_result - TypeError: SearchResult...
==================== 4 failed, 6 passed, 1 error in 0.57s =====================
