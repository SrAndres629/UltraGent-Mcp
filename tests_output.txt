============================= test session starts =============================
platform win32 -- Python 3.13.1, pytest-8.4.2, pluggy-1.6.0
rootdir: C:\Users\acord\OneDrive\Desktop\Biblioteca MCP\Ultragent
configfile: pyproject.toml
plugins: anyio-4.9.0, libtmux-0.53.0, asyncio-1.3.0, html-4.2.0, metadata-3.1.1
asyncio: mode=Mode.AUTO, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 30 items

tests\test_librarian.py ........FF                                       [ 33%]
tests\test_scout.py F.......F.F                                          [ 70%]
tests\test_git_senior_sync.py FFF....F.                                  [100%]

================================== FAILURES ===================================
___________________ TestUnsupportedLanguageError.test_init ____________________

self = <test_librarian.TestUnsupportedLanguageError object at 0x000001B6F0632AD0>

    def test_init(self):
        error = UnsupportedLanguageError('Test language')
>       assert str(error) == 'Lenguaje no soportado: Test language'
E       AssertionError: assert 'Test language' == 'Lenguaje no ...Test language'
E         
E         - Lenguaje no soportado: Test language
E         + Test language

tests\test_librarian.py:124: AssertionError
_________________________ TestParsingError.test_init __________________________

self = <test_librarian.TestParsingError object at 0x000001B6F0632C10>

    def test_init(self):
        error = ParsingError('Test error')
>       assert str(error) == 'Error al parsear el c¾digo: Test error'
E       AssertionError: assert 'Test error' == 'Error al par...o: Test error'
E         
E         - Error al parsear el c¾digo: Test error
E         + Test error

tests\test_librarian.py:129: AssertionError
________________________ test_stack_profile_from_file _________________________

    def test_stack_profile_from_file():
        with patch("scout.json.loads") as mock_json_loads:
            mock_json_loads.return_value = {
                "project_name": "Test Project",
                "core_frameworks": ["framework1", "framework2"],
                "libraries": ["lib1", "lib2"],
                "constraints": {"constraint1": "value1", "constraint2": "value2"},
            }
            profile = StackProfile.from_file(Path("test.json"))
>           assert profile.project_name == "Test Project"
E           AssertionError: assert 'Default' == 'Test Project'
E             
E             - Test Project
E             + Default

tests\test_scout.py:83: AssertionError
____________________ test_repository_health_invalid_input _____________________

self = <unittest.mock._patch object at 0x000001B6F08FD350>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           TypeError: cannot set 'now' attribute of immutable type 'datetime.datetime'

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1609: TypeError

During handling of the above exception, another exception occurred:

repository_health = RepositoryHealth(name='Test Repository', full_name='Test Owner/Test Repository', url='https://github.com/Test Owner/Te...etime.datetime(2026, 2, 6, 5, 17, 16, 370635), has_tests=True, has_typing=True, has_readme=True, commit_frequency=10.0)

    def test_repository_health_invalid_input(repository_health):
>       with patch("scout.datetime.now") as mock_now:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_scout.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001B6F08FD350>
exc_info = (<class 'TypeError'>, TypeError("cannot set 'now' attribute of immutable type 'datetime.datetime'"), <traceback object at 0x000001B6F04AADC0>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
>           setattr(self.target, self.attribute, self.temp_original)
E           TypeError: cannot set 'now' attribute of immutable type 'datetime.datetime'

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1631: TypeError
______________________ test_search_result_invalid_input _______________________

    def test_search_result_invalid_input():
>       result = SearchResult(
            title=None,
            url=None,
        )
E       TypeError: SearchResult.__init__() missing 3 required positional arguments: 'snippet', 'source_type', and 'date'

tests\test_scout.py:193: TypeError
___________________ test_generate_commit_message_empty_diff ___________________

mock_router = <MagicMock name='get_router()' id='1885277079600'>

    def test_generate_commit_message_empty_diff(mock_router):
>       assert generate_commit_message('') == 'chore: minor updates'
E       AssertionError: assert <coroutine object generate_commit_message at 0x000001B6F086ABD0> == 'chore: minor updates'
E        +  where <coroutine object generate_commit_message at 0x000001B6F086ABD0> = generate_commit_message('')

tests\test_git_senior_sync.py:25: AssertionError
________________________ test_generate_commit_message _________________________

mock_router = <MagicMock name='get_router()' id='1885277080608'>

    def test_generate_commit_message(mock_router):
>       assert generate_commit_message('test diff') == 'feat: test commit message'
E       AssertionError: assert <coroutine object generate_commit_message at 0x000001B6F33F1690> == 'feat: test commit message'
E        +  where <coroutine object generate_commit_message at 0x000001B6F33F1690> = generate_commit_message('test diff')

tests\test_git_senior_sync.py:28: AssertionError
___________________ test_generate_commit_message_exception ____________________

mock_router = <MagicMock name='get_router()' id='1885277081616'>

    def test_generate_commit_message_exception(mock_router):
        mock_router.route_task.side_effect = Exception('test exception')
>       assert generate_commit_message('test diff') == 'feat: automate senior git synchronization flow [emergency fallback]'
E       AssertionError: assert <coroutine object generate_commit_message at 0x000001B6F33F2130> == 'feat: automate senior git synchronization flow [emergency fallback]'
E        +  where <coroutine object generate_commit_message at 0x000001B6F33F2130> = generate_commit_message('test diff')

tests\test_git_senior_sync.py:32: AssertionError
________________________ test_git_senior_sync_changes _________________________

mock_subprocess_run = <MagicMock name='run' id='1885277085312'>
mock_logger = <MagicMock name='logger' id='1885277085984'>
mock_router = <MagicMock name='get_router()' id='1885277086656'>

    @pytest.mark.asyncio
    async def test_git_senior_sync_changes(mock_subprocess_run, mock_logger, mock_router):
        mock_subprocess_run.return_value = MagicMock(stdout='test output', returncode=0)
        await git_senior_sync()
>       mock_logger.info.assert_any_call('\u2728 Mensaje Sugerido: feat: test commit message')

tests\test_git_senior_sync.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='logger.info' id='1885277087664'>
args = ('\u2728 Mensaje Sugerido: feat: test commit message',), kwargs = {}
expected = call('\u2728 Mensaje Sugerido: feat: test commit message'), cause = None
actual = [call('\U0001f680 Iniciando Sincronizaci\xf3n Git Senior...'), call("Status output captured. Type: <class 'str'>"), call('\U0001f4c1 Cambio...inteligente...'), call('\u2728 Mensaje Sugerido: feat: automate senior git synchronization flow [emergency fallback]'), ...]
expected_string = "info('\u2728 Mensaje Sugerido: feat: test commit message')"

    def assert_any_call(self, /, *args, **kwargs):
        """assert the mock has been called with the specified arguments.
    
        The assert passes if the mock has *ever* been called, unlike
        `assert_called_with` and `assert_called_once_with` that only pass if
        the call is the most recent one."""
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        cause = expected if isinstance(expected, Exception) else None
        actual = [self._call_matcher(c) for c in self.call_args_list]
        if cause or expected not in _AnyComparer(actual):
            expected_string = self._format_mock_call_signature(args, kwargs)
>           raise AssertionError(
                '%s call not found' % expected_string
            ) from cause
E           AssertionError: info('\u2728 Mensaje Sugerido: feat: test commit message') call not found

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1048: AssertionError
============================== warnings summary ===============================
tests/test_git_senior_sync.py::test_run_git_unexpected_error
  C:\Users\acord\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:2245: RuntimeWarning: coroutine 'generate_commit_message' was never awaited
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_librarian.py::TestUnsupportedLanguageError::test_init - Ass...
FAILED tests/test_librarian.py::TestParsingError::test_init - AssertionError:...
FAILED tests/test_scout.py::test_stack_profile_from_file - AssertionError: as...
FAILED tests/test_scout.py::test_repository_health_invalid_input - TypeError:...
FAILED tests/test_scout.py::test_search_result_invalid_input - TypeError: Sea...
FAILED tests/test_git_senior_sync.py::test_generate_commit_message_empty_diff
FAILED tests/test_git_senior_sync.py::test_generate_commit_message - Assertio...
FAILED tests/test_git_senior_sync.py::test_generate_commit_message_exception
FAILED tests/test_git_senior_sync.py::test_git_senior_sync_changes - Assertio...
=================== 9 failed, 21 passed, 1 warning in 4.37s ===================
